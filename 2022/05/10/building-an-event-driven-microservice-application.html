<!DOCTYPE html>
<html lang="en">

<head><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<link href="https://fonts.googleapis.com/css?family=Merriweather:300|Raleway:400,700" rel="stylesheet">
<link rel="stylesheet" href="/assets/css/style.css">
<title>Learnings from Building an Event-Driven Microservice Application</title>
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Learnings from Building an Event-Driven Microservice Application | Steffen’s Tech Blog</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="Learnings from Building an Event-Driven Microservice Application" />
<meta name="author" content="Steffen Mueller" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="In August/October 2021, we have begun to build a completely new web application which aimed to be a substitution for a former application. When we have started to plan the new application, it was already clear that we wanted to go towards an event-driven application. This article summarizes my impressions and learnings from building this event-driven microservices application in recent months." />
<meta property="og:description" content="In August/October 2021, we have begun to build a completely new web application which aimed to be a substitution for a former application. When we have started to plan the new application, it was already clear that we wanted to go towards an event-driven application. This article summarizes my impressions and learnings from building this event-driven microservices application in recent months." />
<link rel="canonical" href="https://steffenmueller4.github.io/2022/05/10/building-an-event-driven-microservice-application.html" />
<meta property="og:url" content="https://steffenmueller4.github.io/2022/05/10/building-an-event-driven-microservice-application.html" />
<meta property="og:site_name" content="Steffen’s Tech Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-05-10T18:02:30+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Learnings from Building an Event-Driven Microservice Application" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Steffen Mueller"},"dateModified":"2022-05-10T18:02:30+00:00","datePublished":"2022-05-10T18:02:30+00:00","description":"In August/October 2021, we have begun to build a completely new web application which aimed to be a substitution for a former application. When we have started to plan the new application, it was already clear that we wanted to go towards an event-driven application. This article summarizes my impressions and learnings from building this event-driven microservices application in recent months.","headline":"Learnings from Building an Event-Driven Microservice Application","mainEntityOfPage":{"@type":"WebPage","@id":"https://steffenmueller4.github.io/2022/05/10/building-an-event-driven-microservice-application.html"},"url":"https://steffenmueller4.github.io/2022/05/10/building-an-event-driven-microservice-application.html"}</script>
<!-- End Jekyll SEO tag -->


</head><body>
  <main class="container">
    <section class="about">
      <div class="about-header condensed">
      <div class="about-title">
      <a href="/">
        
        <img src="/assets/me.jpg" alt="Steffen Mueller" />
        
      </a>
      <h2 id="title">
        <a href="/">Steffen Mueller</a>
      </h2>
      </div><p class="tagline">Software Engineer</p></div>
      
      <ul class="social about-footer condensed"><a href="https://github.com/steffenmueller4" target="_blank">
          <li>
            <i class="icon-github-circled"></i>
          </li>
        </a><a href="https://www.linkedin.com/in/steffen-mueller-139b8b191" target="_blank">
          <li>
            <i class="icon-linkedin-squared"></i>
          </li>
        </a></ul><p class="about-footer condensed">&copy;
        2024</p>
    </section>
    <section class="content">
      <div class="post-container">
  <a class="post-link" href="/2022/05/10/building-an-event-driven-microservice-application.html">
    <img src="/assets/hero_learnings_from_building_an_edma.svg" class="post-heroimage" alt="Learnings from Building an Event-Driven Microservice Application"><h1 class="post-title">Learnings from Building an Event-Driven Microservice Application</h1>
  </a>
  <div class="post-meta">
    <div class="post-date"><i class="icon-calendar"></i>May 10, 2022</div><ul class="post-categories"><li>Architecture</li><li>Microservices</li><li>Event-Driven Architecture</li><li>Domain-Driven Design</li></ul></div>
  <div class="post">
    <p>In August/October 2021, we have begun to build a completely new web application which aimed to be a substitution for a former application.
When we have started to plan the new application, it was already clear that we wanted to go towards an event-driven application.
This article summarizes my impressions and learnings from building this event-driven microservices application in recent months.</p>

<h2 id="the-beginning">The Beginning</h2>

<blockquote>
  <p>Disclaimer: This article presents my personal opinions and perspectives on the project, so this is not my company’s opinion.</p>
</blockquote>

<p>When we have started to plan the new application in my company, a corporate startup and 100% subsidary of an insurance company, in August 2021, it was crystal clear that the company is rather not an established company with an established development department and stable processes.
There was no team and the idea was to build an entirely new product.
In sum, the plans were quite crazy: Our goal was to build an entirely new product as a greenfield project in the Cloud including new processes within only 6 months—start of development should be October 2021.
The ultimate deadline was the 29th of March 2022 at which the new product was intended to go live in order to replace the existing application that we inherited from a corporate department of the insurance company.</p>

<p>Essentially, those plans made clear that we should rather use rock-solid technology and architecture to not risk our tight timetable.
I remember discussions about monoliths vs. microservices in startups and when to use what (see, e.g.: <a class="citation" href="#Tilkov2015">[1]</a>).
Other discussions were around going with a dedicated backend and frontend or not.
Eventually, we decided to go towards an event-driven microservice application to leverage flexibility and achieve a pluggable, a loosely coupled application, etc. (see also: <a class="citation" href="#Bellemare2020">[2]</a>; for more details on the architecture, we refer to <a href="#the-actual-architecture">this section</a>).
The following sections tell you more about the entire journey.</p>

<h2 id="the-whole-development-in-a-nutshell">The Whole Development in a Nutshell</h2>

<p>When we have started with the development in October 2021, we began with creating a <em>domain model</em> (see also: <a href="#the-domain-model">this section</a>).
According to <a href="https://en.wikipedia.org/wiki/Domain-driven_design">Domain-driven Design (DDD)</a>, a domain model is a software model of the business domain typically containing well-known nouns of the domain—often implemented as an object model.
Such a domain model also acts as a <em>ubiquitous language</em> to improve the communication between software developers and domain experts within a <em>bounded context</em>.
The bounded context encapsulates a certain set of assumptions, a common ubiquitous language, and a particular domain model in a coherent environment.
It is used for defining conceptual boundaries between applications and/or microservices <a class="citation" href="#Vernon2016">[3]</a>, <a class="citation" href="#Fowler2014">[4]</a>.
In general, there is the rule of thumb that there is one or sometimes more microservice per bounded context, but you should rather not have one microservice dealing with more than one bounded context <a class="citation" href="#Newman2019">[5]</a>.</p>

<p>We then defined <em>domain events</em> in this domain model collectively.
For that, we conducted an event storming workshop with some experts which served as a basis (see also, e.g.: <a class="citation" href="#WikipediaEventStorming2022">[6]</a>, <a class="citation" href="#Stenberg2016">[7]</a>).
Following Vaughn Vernon’s definition, a domain event is a record of a business-significant occurrence in a bounded context <a class="citation" href="#Vernon2016">[3]</a>.
In the automotive maintenance (in German: Autoservice) domain of my company, such a record of a business-significant occurrence is, for example, a <em>booking</em> of a service such as an oil change (see also: <a href="#the-domain-model">this section</a>).
Concretely, the booking domain event is raised by our microservice handling the backend work of our core booking userflow when a customer books a service.
The event is essential for a lot of other services, applications, and departments such as our customer support team which needs to know about the bookings of a customer to handle support cases when a customer calls in.
Furthermore, the bookings of a customer are relevant for the management, the product, and the marketing team as well as many more teams to analyze, improve, and advertize our product.</p>

<p>While we were implementing the booking domain event, we have seen soon that such a booking can have different states in our domain such as initially <em>created</em>, <em>paid</em>, <em>upcoming</em>, or <em>finalized</em>.
For example, a customer can book a car service (created state) and pay it online via credit card (paid state), but does not show up in the garage.
So, the booking stays in the upcoming state and is not finalized.
Maybe, the customer then want to get reimbursed.
These state changes of the booking domain event, thus, had to be communicated.</p>

<p>Although we had to cross a lot of obstacles during the entire development, we eventually came up with a flexible, loosely coupled, and pluggable solution based on event-driven microservices.
The core microservice that emits the booking domain event is not directly connected with the other microservices and systems consuming the event such as the customer relationship management (CRM) system that the support team uses.
Everything is decoupled via an <em>event broker</em> (see also: <a href="#the-architecture">this section</a>).
For the CRM system, we, for instance, developed an independent microservice that listen to the domain events and uses the API of the CRM system to make the booking information available to the support team.
Another microservice listens to the booking domain events to cummulate business metrics for the product team.
Soon, we will implement a data lake to which the booking domain events will also be written to persist them for further analytics.</p>

<p>In the next sections, you can read about further details of the overall solution such as the <a href="#the-domain-model">domain model</a>, the <a href="#the-architecture">architecture</a>, or the <a href="#technical-perspective-on-domain-events">technical perspective on domain events</a>.</p>

<h2 id="the-domain-model">The Domain Model</h2>

<p><img src="/assets/car-services-domain-model.png" alt="Partial Domain Model of Car Services Domain" /></p>

<p>The partial domain model—the full domain model is simply too complex—is depicted in the figure above (it is also freestyled a little bit for the sake of this article).
The <em>customer</em> is at the center of our domain model.
When the customer wants to book a <em>service</em> she searches for either a <em>garage</em> which provides the services or for the service such as an <em>oil change</em> or a <em>wheel change</em> which is provided by a garage.
When the customer selects the garage and the service, she can book the service at the garage—this is the booking domain event (see also: <a href="#the-whole-development-in-a-nutshell">this section</a>).</p>

<p>In general, each connection between two entities in the domain model can reveal an interesting domain event.
For example, you may also be interested in the domain event <em>ServiceSelectedEvent</em> or <em>GarageSelectedEvent</em> between the customer and the service respectively the garage entity in your business.
We decided to only implement the booking domain event for now, because we had to focus on the essentials.
However, we may implement the other domain events soon to better analyze our business.</p>

<p>In sum, the domain model helped us a lot to structure our domain and to come up with relevant domain events.
It is also very good when explaining newcomers our domain and the entities they will deal with.
Especially, the domain model and, thus, the ubiquitous language helped us to speak more precisely with each other.
It helped us to get rid of a lot of synonyms we used in the team.</p>

<p>But when you now want to start your first project with DDD, please be sure to also read about valid criticism.
For example, Stefan Tilkov criticizes the hype about DDD in recent years in the two articles <a class="citation" href="#Tilkov2021">[8]</a> and <a class="citation" href="#Tilkov2021a">[9]</a>.
Furthermore, it can be quite hard to learn DDD—especially, when you want to start off with Eric Evans’ book (see also: <a class="citation" href="#Evans2003">[10]</a>).
We also did not follow DDD in the purest way when modeling our domain or conducting the event storming workshop—we “freestyled” a lot.
So, please always keep in mind that also other system design approaches can lead to excellent results.
However, I definitely recommend—like Stefan Tilkov: “Make DDD part of your tool set, but make sure you don’t stop there. There is a life beyond DDD. Not every good design needs to be Domain-driven […]” <a class="citation" href="#Tilkov2021a">[9]</a></p>

<h2 id="the-architecture">The Architecture</h2>

<p><img src="/assets/car-services-architecture-overview.png" alt="Partial Architecture of Car Services Application" /></p>

<p>In the figure above, you can see the relevant parts of our architecture of the Autoservice application.
The application consists of a <a href="https://nextjs.org/">Next.js</a> frontend application, two <a href="https://spring.io/projects/spring-boot">Spring Boot</a> backend applications, an <a href="https://kafka.apache.org/">Apache Kafka</a> server as an event broker (see also: <a class="citation" href="#Bellemare2020">[2]</a> for the difference between a message and an event broker) providing topics for the different event messages such as the booking domain event, and a Kafka consumer reading all event messages that should be written to our CRM system.</p>

<p>The frontend application communicates via synchronous REST API calls with the two backend microservices.
The backend microservices encapsulate the API for the core booking userflow and the API for the account functionality.
For the rest of this section, we concentrate on the core backend microservice.</p>

<p>The core backend microservice encapsulates, as mentioned before, the API for the core booking userflow, so this is the microservice emitting the booking domain event.
As described in the previous section (see: <a href="#the-domain-model">this section</a>), the booking domain event is raised when a customer books a service such as an oil change.
The booking domain event is sent to a Kafka topic called <em>BookingEvent</em>.
Different Kafka consumers are listening to the topic such as the account backend microservice or the CRM Kafka consumer.</p>

<p>The account backend microservice stores the booking domain events per user in the micoservice’s database to show a user her booking history in the account.
The CRM Kafka consumer listens to the Kafka topic to store every booking in the CRM system.
Here, you can already see that we can plug in a lot of other loosely coupled event-driven microservices to build other functionality in our application.
The difficulties come with the management of the domain event messages which is described in more detail in the next section.</p>

<h2 id="technical-perspective-on-domain-events">Technical Perspective on Domain Events</h2>

<p>As mentioned, we decided to go with <a href="https://kafka.apache.org/">Kafka</a> as an event broker (see: <a href="#the-architecture">this section</a>).
Following the recommendation of Adam Bellmare in <a class="citation" href="#Bellemare2020">[2]</a>, we defined our domain event messages explicitely via <a href="https://developers.google.com/protocol-buffers">Protocol Buffers</a> in a binary format.
At the moment, we do not have a schema registry but are using a central repository storing all domain event message definitions.
This, in general, works for now.
However, we are currently looking at schema registries such as Confluent’s <a href="https://docs.confluent.io/platform/current/schema-registry/index.html">Schema Registry</a> which is also available at Github (see: <a href="https://github.com/confluentinc/schema-registry">Confluent Schema Registry for Kafka at Github</a>), because updating all the consumers with new domain event message version is already very cumbersome—even though we do not have so many consumers yet.</p>

<p>In a Goto Conference talk in 2017, Martin Fowler differentiates between four patterns of event-driven architecture <a class="citation" href="#Fowler2017">[11]</a>:</p>
<ol>
  <li><em>Event notifications</em> - the system emitting the event message provides API to get the further data about the event. So, the event-receiving system invokes API of the event-emitting system to handle state changes <a class="citation" href="#Fowler2017">[11]</a>.</li>
  <li><em>Event-carried state transfer</em> - the event message contains all information about the state change, so the event-receiving system has all the necessary information to react to the state change. In contrast to the event notification pattern, the emitting and the receiving systems can live independently from each other, because the receiving system does not have to call an API to get the event details <a class="citation" href="#Fowler2017">[11]</a>.</li>
  <li><em>Event sourcing</em> - instead of storing the state of a business entity in a database, event messages are saved in consecutive order in an event store, and the state of the business entity is, then, reconstructed by replaying the event messages from the event store <a class="citation" href="#Richardson2021">[12]</a>.</li>
  <li><em>Command query responsibility segregation (CQRS)</em> - at the heart of CQRS, is the notion that you can use a different model to update information than the model you use to read information. For more information about CQRS, we refer, for example, to <a class="citation" href="#Fowler2011">[13]</a> or <a class="citation" href="#Richardson2021a">[14]</a>.</li>
</ol>

<p>In general, our system uses the event-carried state transfer pattern.
Thus, the application still uses databases for storing its state, but emits the domain events to Kafka on top of storing the state to the database.
This way, we were able to have a fast pace in the project due to not changing the way people think about building software while also benefitting from sending out domain events (see also: <a href="#the-beginning">this section</a>).
With all people with very different background in the entire project, the introduction of domain events was hard enough even without the need to introduce difficult concepts such as event sourcing or CQRS (see also: <a class="citation" href="#Fowler2017">[11]</a> for criticism about Event Sourcing and CQRS as well as <a class="citation" href="#Fowler2011">[13]</a> about CQRS).
In some use cases, we also use the event sourcing pattern nowadays.</p>

<p>When looking back to the project, it is essential that your team understands what you want to achieve with building event-driven microservices.
For example, they need to know what systems you want to integrate to build proper event messages.
Furthermore, I recommend that the team should know the four patterns of event-driven architecture.
This improves the overall understanding of the entire event-driven architecture and leads to better solutions.
For example, the knowledge of the event sourcing pattern improves the solution when building a history of something such as the booking history in our project.</p>

<p>As mentioned already, you should directly think about a schema registry for managing your domain event messages.
As soon as the number of microservices increases, you will be happy when you do not have to update all domain event message definitions or coordinate the rollout.
Furthermore, your team needs to learn about Protocol Buffers message compatability.
A good read about that is, for example, <a class="citation" href="#Gramila2021">[15]</a>.</p>

<p>Last but not least, make sure that your domain event messages are replayable as Adam Bellmare recommends in <a class="citation" href="#Bellemare2020">[2]</a>.
For example, our first versions of our Kafka consumers were creating an ID when inserting new entries to some systems.
Thus, storing the events was not replayable, because the ID was changing when replaying.
Please either create the unique ID in the source system of the event or derive the ID from the event in a deterministic way.
Also, consider to use upserts in the destination systems.</p>

<h2 id="conclusions">Conclusions</h2>

<p>In sum, the combination of DDD and event-driven microservices worked well in our project.
Building the domain model and defining the domain events based on the domain model, was a good move for the communication within the team.
The domain model helped us to be clear about our common (ubiquitious) language and the interdependencies between the entities.
Aligning the domain events based on the domain model really helped the developers to understand when the domain event has to be raised.</p>

<p>Currently, we definitely benefit from our event-driven microservices approach when building new integrations, although you already heard about a lot of improvement points such as the schema registry or replayable events.
All in all, we are very happy with the choice of going towards an event-driven microservice architecture.
The application is—in our opinion—flexible, pluggable, and loosely coupled (see also: <a href="#the-beginning">this section</a>).</p>

<p>We can definitely encourage you in building such an event-driven microservices application.</p>

<h2 id="references">References</h2>

<ol class="bibliography"><li><span id="Tilkov2015">S. Tilkov, <a href="https://martinfowler.com/articles/dont-start-monolith.html">“Don’t start with a monolith - ... when your goal is a microservices architecture.”</a> 09-Jun-2015.</span></li>
<li><span id="Bellemare2020">A. Bellemare, <i>Building Event-Driven Microservices - Leveraging Organizational Data at Scale</i>. O’Reilly UK Ltd., 2020.</span></li>
<li><span id="Vernon2016">V. Vernon, <i>Domain-Driven Design Distilled</i>. Addison Wesley, 2016.</span></li>
<li><span id="Fowler2014">M. Fowler, <a href="https://martinfowler.com/bliki/BoundedContext.html">“Bounded Context.”</a> Jan-2014.</span></li>
<li><span id="Newman2019">S. Newman, <i>Monolith to Microservices</i>. O’Reilly, 2019.</span></li>
<li><span id="WikipediaEventStorming2022">Wikipedia contributors, <a href="https://en.wikipedia.org/w/index.php?title=Event_storming&amp;oldid=1067022209">“Event storming.”</a> Wikipedia, Jan-2022.</span></li>
<li><span id="Stenberg2016">J. Stenberg, <a href="https://www.infoq.com/news/2016/12/microservices-events-ddd/">“Start with Events and DDD When Building Microservices.”</a> 28-Dec-2016.</span></li>
<li><span id="Tilkov2021">S. Tilkov, <a href="https://tilkov.com/post/2021/03/01/ddd-is-overrated/">“DDD is Overrated.”</a> 01-Mar-2021.</span></li>
<li><span id="Tilkov2021a">S. Tilkov, <a href="https://www.innoq.com/de/blog/is-domain-driven-design-overrated/">“Is Domain-driven Design overrated?”</a> 02-Mar-2021.</span></li>
<li><span id="Evans2003">E. J. Evans, <i>Domain-Driven Design</i>. Addison Wesley, 2003.</span></li>
<li><span id="Fowler2017">M. Fowler, <a href="https://youtu.be/STKCRSUsyP0">“The Many Meanings of Event-Driven Architecture.”</a> 2017.</span></li>
<li><span id="Richardson2021">C. Richardson, <a href="https://microservices.io/patterns/data/event-sourcing.html">“Microservices.io - Pattern: Event sourcing.”</a> 2021.</span></li>
<li><span id="Fowler2011">M. Fowler, <a href="https://martinfowler.com/bliki/CQRS.html">“CQRS.”</a> Jul-2011.</span></li>
<li><span id="Richardson2021a">C. Richardson, <a href="https://microservices.io/patterns/data/cqrs.html">“Microservices.io - Pattern: Command Query Responsibility Segregation (CQRS).”</a> 2021.</span></li>
<li><span id="Gramila2021">J. Gramila, <a href="https://earthly.dev/blog/backward-and-forward-compatibility/">“Protocol Buffers Best Practices for Backward and Forward Compatibility.”</a> 21-May-2021.</span></li></ol>

<h2 id="acknowledgements">Acknowledgements</h2>

<p>Huge thanks go to the entire product and development team of <a href="https://www.huk-autoservice.de">HUK-Autoservice</a> as well as our project partners <a href="https://www.edenspiekermann.com">Edenspiekermann</a> and <a href="https://foobar.agency">foobar Agency GmbH</a> for the awesome work.</p>

  </div></div>

    </section>
    <footer class="condensed">
      <ul class="social about-footer condensed"><a href="https://github.com/steffenmueller4" target="_blank">
          <li>
            <i class="icon-github-circled"></i>
          </li>
        </a><a href="https://www.linkedin.com/in/steffen-mueller-139b8b191" target="_blank">
          <li>
            <i class="icon-linkedin-squared"></i>
          </li>
        </a></ul><p class="about-footer condensed">&copy;
        2024</p>
    </footer>
  </main>
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-CD0VW38PQP"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-CD0VW38PQP');
  </script>
  <script src="/assets/js/simple-jekyll-search.min.js"></script>
  <script src="/assets/js/search.js"></script>
  
</body>

</html>
